{"version":3,"file":"index.esm.js","sources":["../src/enhancers/helpers/index.ts","../src/enhancers/helpers/logger.ts","../src/constants.ts","../src/enhancers/withPersistTokens/constants.ts","../src/enhancers/withPersistTokens/helpers.ts","../src/enhancers/withFingerprint/constants.ts","../src/enhancers/withFingerprint/helpers.ts","../src/enhancers/withFingerprint/index.ts","../src/enhancers/withLastLoggedInUser/constants.ts","../src/enhancers/withLastLoggedInUser/helpers.ts","../src/enhancers/withLastLoggedInUser/index.ts","../src/enhancers/withNotifications/helpers.ts","../src/enhancers/withNotifications/index.ts","../src/enhancers/withPersistTokens/index.ts","../src/sdk/webauthn.ts","../src/apiPaths.ts","../src/sdk/fedcm.ts","../src/sdk/flow.ts","../src/sdk/index.ts","../src/index.ts","../src/enhancers/helpers/compose.ts","../src/enhancers/withAutoRefresh/index.ts","../src/enhancers/withAutoRefresh/helpers.ts","../src/enhancers/withAnalytics.ts"],"sourcesContent":["import { JWTResponse, UserResponse } from '@descope/core-js-sdk';\nimport { CoreSdkConfig } from '../../types';\n\n/**\n * Add hooks to an existing core-sdk config\n */\nexport const addHooks = <Config extends CoreSdkConfig>(\n  config: Config,\n  hooks: Config['hooks'],\n): Config => {\n  ['beforeRequest', 'afterRequest'].reduce(\n    (acc, key) => {\n      acc[key] = []\n        .concat(config.hooks?.[key] || [])\n        .concat(hooks?.[key] || []);\n\n      return acc;\n    },\n    (config.hooks ??= {}),\n  );\n\n  return config;\n};\n\nexport { compose } from './compose';\n\n/**\n * Extract auth info (JWT response) from fetch response\n * We assume that the auth info is under a \"authInfo\" attribute (flow response)\n * Or the body itself (other auth methods response)\n */\nexport const getAuthInfoFromResponse = async (\n  res: Response,\n): Promise<Partial<JWTResponse>> => {\n  if (!res?.ok) return {};\n  const body = await res?.clone().json();\n  return body?.authInfo || body || {};\n};\n\n/**\n * Extract user from fetch response\n * User my exist under \"user\" attribute (auth methods response)\n * Or the body itself (when calling \"me\")\n */\nexport const getUserFromResponse = async (\n  res: Response,\n): Promise<UserResponse> | undefined => {\n  const authInfo = await getAuthInfoFromResponse(res);\n\n  return (\n    authInfo?.user ||\n    (authInfo?.hasOwnProperty('userId')\n      ? (authInfo as UserResponse)\n      : undefined)\n  );\n};\n\nexport const isLocalStorage = typeof localStorage !== 'undefined';\n\nexport const setLocalStorage = (key: string, value: string) =>\n  isLocalStorage && localStorage?.setItem(key, value);\nexport const getLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.getItem(key);\nexport const removeLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.removeItem(key);\n","const logger = {\n  debug: (...args: any[]) => {\n    // eslint-disable-next-line no-console\n    console.debug(...args);\n  },\n};\n\nexport default logger;\n","// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n\n// Maximum timeout value for setTimeout\n// For more information, refer to https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\nexport const MAX_TIMEOUT = Math.pow(2, 31) - 1;\n","/** Default name for the session cookie name / local storage key */\nexport const SESSION_TOKEN_KEY = 'DS';\n/** Default name for the refresh local storage key */\nexport const REFRESH_TOKEN_KEY = 'DSR';\n","import { JWTResponse } from '@descope/core-js-sdk';\nimport Cookies from 'js-cookie';\nimport { BeforeRequestHook } from '../../types';\nimport { REFRESH_TOKEN_KEY, SESSION_TOKEN_KEY } from './constants';\nimport {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport { CookieConfig, SameSite } from './types';\n\n/**\n * Store the session JWT as a cookie on the given domain and path with the given expiration.\n * This is useful so that the application backend will automatically get the cookie for the session\n * @param name cookie name\n * @param value The JWT to store as a cookie\n * @param cookieParams configuration that is usually returned from the JWT\n */\nfunction setJwtTokenCookie(\n  name: string,\n  value: string,\n  {\n    cookiePath,\n    cookieDomain,\n    cookieExpiration,\n    cookieSameSite = 'Strict',\n  }: Partial<JWTResponse & { cookieSameSite: SameSite }>,\n) {\n  if (value) {\n    const expires = new Date(cookieExpiration * 1000); // we are getting response from the server in seconds instead of ms\n    // Since its a JS cookie, we don't set the domain because we want the cookie to be on the same domain as the application\n    const domainMatches = isCurrentDomainOrParentDomain(cookieDomain);\n    Cookies.set(name, value, {\n      path: cookiePath,\n      domain: domainMatches ? cookieDomain : undefined,\n      expires,\n      sameSite: cookieSameSite,\n      secure: true,\n    });\n  }\n}\n\n/*\n * Check if the cookie domain is the same as the current domain or the parent domain\n * Examples:\n * 1. cookie domain: 'example.com', current domain: 'example.com' => true\n * 2. cookie domain: 'example.com', current domain: 'sub.example.com' => true\n * 3. cookie domain: 'example.com', current domain: 'sub.sub.example.com' => true\n * 4. cookie domain: 'example.com', current domain: 'another.com' => false\n * 5. cookie domain: 'example.com', current domain: 'example.co.il' => false\n */\nfunction isCurrentDomainOrParentDomain(cookieDomain: string): boolean {\n  const currentDomain = window.location.hostname;\n  const currentDomainParts = currentDomain.split('.');\n  const cookieDomainParts = cookieDomain.split('.');\n\n  // check if the cookie domain items are the last items in the current domain\n  const currentDomainSuffix = currentDomainParts\n    .slice(-cookieDomainParts.length)\n    .join('.');\n  return currentDomainSuffix === cookieDomain;\n}\n\nexport const persistTokens = (\n  { refreshJwt, sessionJwt, ...cookieParams } = {} as Partial<JWTResponse>,\n  sessionTokenViaCookie: boolean | CookieConfig = false,\n  storagePrefix = '',\n) => {\n  // persist refresh token\n  refreshJwt &&\n    setLocalStorage(`${storagePrefix}${REFRESH_TOKEN_KEY}`, refreshJwt);\n\n  // persist session token\n  if (sessionJwt) {\n    sessionTokenViaCookie\n      ? setJwtTokenCookie(SESSION_TOKEN_KEY, sessionJwt, {\n          ...cookieParams,\n          cookieSameSite:\n            sessionTokenViaCookie === true\n              ? 'Strict'\n              : sessionTokenViaCookie['sameSite'],\n        })\n      : setLocalStorage(`${storagePrefix}${SESSION_TOKEN_KEY}`, sessionJwt);\n  }\n};\n\n/** Return the refresh token from the localStorage. Not for production usage because refresh token will not be saved in localStorage. */\nexport function getRefreshToken(prefix: string = '') {\n  return getLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`) || '';\n}\n\n/**\n * Return the session token. first try to get from cookie, and fallback to local storage\n * See sessionTokenViaCookie option for more details about session token location\n */\nexport function getSessionToken(prefix: string = ''): string {\n  return (\n    Cookies.get(SESSION_TOKEN_KEY) ||\n    getLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`) ||\n    ''\n  );\n}\n\n/** Remove both the localStorage refresh JWT and the session cookie */\nexport function clearTokens(prefix: string = '') {\n  removeLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`);\n  Cookies.remove(SESSION_TOKEN_KEY);\n}\n\nexport const beforeRequest =\n  (prefix?: string): BeforeRequestHook =>\n  (config) =>\n    Object.assign(config, { token: config.token || getRefreshToken(prefix) });\n","import { IS_BROWSER } from '../../constants';\n\nconst FINGERPRINT_PUBLIC_KEY = 'fingerprint.public.key';\nconst FINGERPRINT_ENDPOINT_URL = 'fingerprint.endpoint.url';\n\n/** Fingerprint.js cloudflare integration */\nexport const FP_EP_URL =\n  (IS_BROWSER && localStorage?.getItem(FINGERPRINT_ENDPOINT_URL)) ||\n  'https://api.descope.com';\nexport const FP_CF_ENDPOINT_PATH = '/fXj8gt3x8VulJBna/x96Emn69oZwcd7I6';\nexport const FP_CF_SCRIPT_PATH = '/fXj8gt3x8VulJBna/w78aRZnnDZ3Aqw0I';\n/** Fingerprint visitor data */\nexport const FP_BODY_DATA = 'fpData';\n/** Session ID for visitor */\nexport const VISITOR_SESSION_ID_PARAM = 'vsid';\n/** Request ID for visitor */\nexport const VISITOR_REQUEST_ID_PARAM = 'vrid';\n/** FP storage key */\nexport const FP_STORAGE_KEY = 'fp';\n// Storage FP Keys TTL is 24 hours\nexport const STORAGE_TTL_MS = 24 * 60 * 60 * 1000;\n","import {\n  load,\n  defaultEndpoint,\n  defaultScriptUrlPattern,\n} from '@fingerprintjs/fingerprintjs-pro';\nimport {\n  FP_EP_URL,\n  FP_CF_ENDPOINT_PATH,\n  FP_CF_SCRIPT_PATH,\n  FP_STORAGE_KEY,\n  STORAGE_TTL_MS,\n  VISITOR_REQUEST_ID_PARAM,\n  VISITOR_SESSION_ID_PARAM,\n} from './constants';\nimport { FingerprintObject } from './types';\n\nconst createFingerprintObject = (\n  sessionId: string,\n  requestId: string,\n): FingerprintObject => ({\n  [VISITOR_SESSION_ID_PARAM]: sessionId,\n  [VISITOR_REQUEST_ID_PARAM]: requestId,\n});\n\n/** Generate UUID based on current time and some randomness */\nconst generateUUID = () => {\n  // return alphanumeric, sortable uuid of 27 characters\n  return (\n    Date.now().toString(36) +\n    Math.random().toString(36).substring(2) + // removing '0.' prefix\n    Math.random().toString(36).substring(2)\n  ).substring(0, 27);\n};\n\n// Set FP data to storage with expiration\n// We set the request id and session id together so they will have the same TTL\n// This implementation is based on https://www.sohamkamani.com/javascript/localstorage-with-ttl-expiry/\nconst setFPToStorage = (value: FingerprintObject) => {\n  const now = new Date();\n  // `item` is an object which contains the value\n  // as well as the time when it's supposed to expire\n  const item = {\n    value,\n    expiry: now.getTime() + STORAGE_TTL_MS,\n  };\n  localStorage.setItem(FP_STORAGE_KEY, JSON.stringify(item));\n};\n\n// Get Fingerprint from storage, will return null if not exists, or if expired\nconst getFPFromStorage = (returnExpired = false): FingerprintObject => {\n  const itemStr = localStorage.getItem(FP_STORAGE_KEY);\n  // if the item doesn't exist, return null\n  if (!itemStr) {\n    return null;\n  }\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  // compare the expiry time of the item with the current time\n  // return null if needed\n  if (now.getTime() > item.expiry && !returnExpired) {\n    return null;\n  }\n  return item.value;\n};\n\n/**\n * Ensure fingerprint ids (request id, session id) exist.\n * If not, It will generate and load them into to browser storage.\n * NOTE: Using fingerprintJS data has cost, use considerably.\n * @param fpKey FingerprintJS API key\n */\nexport const ensureFingerprintIds = async (\n  fpKey: string,\n  baseUrl = FP_EP_URL,\n) => {\n  try {\n    if (getFPFromStorage()) {\n      // FP is already in storage, no need to\n      return;\n    }\n\n    const sessionId = generateUUID();\n\n    const endpointUrl = new URL(baseUrl);\n    endpointUrl.pathname = FP_CF_ENDPOINT_PATH;\n\n    const patterUrl = new URL(baseUrl);\n    patterUrl.pathname = FP_CF_SCRIPT_PATH;\n    const scriptUrlPattern =\n      patterUrl.toString() +\n      '?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>';\n\n    // load from FingerprintJS\n    const agentP = load({\n      apiKey: fpKey,\n      endpoint: [\n        endpointUrl.toString(),\n        defaultEndpoint, // Fallback to default endpoint in case of error\n      ],\n      scriptUrlPattern: [\n        scriptUrlPattern,\n        defaultScriptUrlPattern, // Fallback to default CDN in case of error\n      ],\n    });\n\n    const agent = await agentP;\n    const { requestId } = await agent.get({ linkedId: sessionId });\n    const fpData = createFingerprintObject(sessionId, requestId);\n    setFPToStorage(fpData);\n  } catch (ex) {\n    // eslint-disable-next-line no-console\n    console.warn('Could not load fingerprint', ex);\n  }\n};\n\n/**\n * Get Fingerprint data (request ids) from storage, or create empty object\n * If data is expired, return it anyway\n */\nexport const getFingerprintData = (): FingerprintObject | null => {\n  // get from storage if exists\n  return getFPFromStorage(true);\n};\n\n/** Clear Fingerprint data from storage */\nexport const clearFingerprintData = () => {\n  localStorage.removeItem(FP_STORAGE_KEY);\n};\n","import { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport { FP_BODY_DATA } from './constants';\nimport { ensureFingerprintIds, getFingerprintData } from './helpers';\nimport { FingerprintOptions } from './types';\n\nconst beforeRequest: BeforeRequestHook = (config) => {\n  const data = getFingerprintData();\n  if (data && config.body) {\n    config.body[FP_BODY_DATA] = data;\n  }\n\n  return config;\n};\n\n/**\n * Add fingerprint data to outgoing requests\n */\nexport const withFingerprint =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ fpKey, fpLoad, ...config }: Parameters<T>[0] & FingerprintOptions) => {\n    if (!IS_BROWSER) {\n      // Fingerprint is a client side only capability and will not work when running in the server (SSR)\n      return createSdk(config);\n    }\n\n    // load fingerprint now if needed\n    if (fpKey && fpLoad) {\n      ensureFingerprintIds(fpKey).catch(\n        // istanbul ignore next\n        () => null,\n      );\n    }\n\n    // Hook added always because fingerprint can be dynamic using flows\n    return createSdk(addHooks(config, { beforeRequest }));\n  };\n","/** Login Id of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_LOGIN_ID = 'dls_last_user_login_id';\n\n/** Display name of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_DISPLAY_NAME =\n  'dls_last_user_display_name';\n","import {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  LOCAL_STORAGE_LAST_USER_LOGIN_ID,\n  LOCAL_STORAGE_LAST_USER_DISPLAY_NAME,\n} from './constants';\n\nexport const setLastUserLoginId = (loginId: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID, loginId);\n};\n\nexport const getLastUserLoginId = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const removeLastUserLoginId = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const setLastUserDisplayName = (displayName: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME, displayName);\n};\n\nexport const getLastUserDisplayName = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n\nexport const removeLastUserDisplayName = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, CoreSdk } from '../../types';\nimport { addHooks, getUserFromResponse } from '../helpers';\nimport {\n  getLastUserLoginId,\n  removeLastUserLoginId,\n  setLastUserLoginId,\n  getLastUserDisplayName,\n  removeLastUserDisplayName,\n  setLastUserDisplayName,\n} from './helpers';\nimport { LastLoggedInUserOptions } from './types';\n\n/**\n * Adds last logged in user to flow start request\n */\n// eslint-disable-next-line import/exports-last\nexport const withLastLoggedInUser =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({\n    storeLastAuthenticatedUser = true,\n    keepLastAuthenticatedUserAfterLogout = false,\n    ...config\n  }: Parameters<T>[0] & LastLoggedInUserOptions): ReturnType<T> & {\n    getLastUserLoginId: typeof getLastUserLoginId;\n    getLastUserDisplayName: typeof getLastUserDisplayName;\n  } => {\n    if (!storeLastAuthenticatedUser) {\n      // We assign getLastUserLoginId and getLastUserDisplayName to the sdk\n      // To keep the return type consistent\n      return Object.assign(createSdk(config), {\n        getLastUserLoginId,\n        getLastUserDisplayName,\n      }) as any;\n    }\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const userDetails = await getUserFromResponse(res);\n      const loginId = userDetails?.loginIds?.[0];\n      const displayName = userDetails?.name;\n      if (loginId) {\n        setLastUserLoginId(loginId);\n        setLastUserDisplayName(displayName);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    let wrappedSdk = wrapWith(sdk, ['flow.start'], startWrapper);\n    wrappedSdk = wrapWith(\n      wrappedSdk,\n      ['logout', 'logoutAll'],\n      logoutWrapper(keepLastAuthenticatedUserAfterLogout),\n    );\n    return Object.assign(wrappedSdk, {\n      getLastUserLoginId,\n      getLastUserDisplayName,\n    }) as any;\n  };\n\nconst startWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    args[1] = args[1] || {};\n    const [, options = {}] = args as unknown as Parameters<\n      CoreSdk['flow']['start']\n    >;\n    const loginId = getLastUserLoginId();\n    const displayName = getLastUserDisplayName();\n\n    if (loginId) {\n      options.lastAuth ??= {};\n      options.lastAuth.loginId = loginId;\n      options.lastAuth.name = displayName;\n    }\n\n    const resp = await fn(...args);\n\n    return resp;\n  };\n\nconst logoutWrapper =\n  (keepOnLogout?: boolean): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n    if (keepOnLogout) {\n      return resp;\n    }\n\n    removeLastUserLoginId();\n    removeLastUserDisplayName();\n\n    return resp;\n  };\n","// create publisher/subscriber instances\nexport function createPubSub<T extends any>() {\n  const cbs = [];\n\n  const sub = (cb: (data: T) => void) => {\n    const idx = cbs.push(cb) - 1;\n    return () => cbs.splice(idx, 1);\n  };\n\n  const pub = (data: T) => {\n    cbs.forEach((cb) => cb(data));\n  };\n\n  return { pub, sub };\n}\n","import { SdkFnWrapper, UserResponse, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk, WebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport {\n  addHooks,\n  getAuthInfoFromResponse,\n  getUserFromResponse,\n} from '../helpers';\nimport { createPubSub } from './helpers';\n\n/**\n * Adds 3 event functions to the sdk,\n * onSessionTokenChange: Gets a callback and call it whenever there is a change in session token\n * onIsAuthenticatedChange: Gets a callback and call it whenever there is a change in authentication status\n * onUserChange: Gets a callback and call it whenever there is a change in current logged in user\n */\nexport const withNotifications =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) => {\n    const sessionExpirationPS = createPubSub<number | null>();\n    const sessionPS = createPubSub<string | null>();\n    const userPS = createPubSub<UserResponse | null>();\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        sessionPS.pub(null);\n        userPS.pub(null);\n        sessionExpirationPS.pub(null);\n      } else {\n        const userDetails = await getUserFromResponse(res);\n        if (userDetails) userPS.pub(userDetails);\n\n        const { sessionJwt, sessionExpiration } =\n          await getAuthInfoFromResponse(res);\n        if (sessionJwt) sessionPS.pub(sessionJwt);\n\n        if (sessionExpiration || sessionJwt) {\n          // We also publish the session expiration if there is a session jwt\n          // as a temporary fix for the issue where the session expiration is not\n          // being sent in the response in Flows (42 is a magic number)\n          sessionExpirationPS.pub(sessionExpiration || 42);\n        }\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n\n        sessionPS.pub(null);\n        userPS.pub(null);\n        sessionExpirationPS.pub(null);\n\n        return resp;\n      };\n\n    const wrappedSdk = wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n\n    return Object.assign(wrappedSdk, {\n      onSessionTokenChange: sessionPS.sub,\n      onUserChange: userPS.sub,\n      onIsAuthenticatedChange: (cb: (isAuthenticated: boolean) => void) => {\n        // If and only if there is a session expiration, then the user is authenticated\n        return sessionExpirationPS.sub((exp) => {\n          cb(!!exp);\n        });\n      },\n    });\n  };\n","/* eslint-disable import/exports-last */\nimport { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  beforeRequest,\n  clearTokens,\n  getRefreshToken,\n  getSessionToken,\n  persistTokens,\n} from './helpers';\nimport { CookieConfig, PersistTokensOptions, SameSite } from './types';\n\n/**\n * Persist authentication tokens in cookie/storage\n */\nexport const withPersistTokens =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  <A extends CookieConfig>({\n    persistTokens: isPersistTokens,\n    sessionTokenViaCookie,\n    storagePrefix,\n    ...config\n  }: Parameters<T>[0] & PersistTokensOptions<A>): A extends false\n    ? ReturnType<T>\n    : ReturnType<T> & {\n        getRefreshToken: () => string;\n        getSessionToken: () => string;\n      } => {\n    if (!isPersistTokens || !IS_BROWSER) {\n      if (isPersistTokens) {\n        // Storing auth tokens in local storage and cookies are a client side only capabilities\n        // and will not be done when running in the server\n      }\n      return createSdk(config) as any;\n    }\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      const isManagementApi = /^\\/v\\d+\\/mgmt\\//.test(req.path);\n\n      if (res?.status === 401) {\n        if (!isManagementApi) {\n          clearTokens(storagePrefix);\n        }\n      } else {\n        persistTokens(\n          await getAuthInfoFromResponse(res),\n          sessionTokenViaCookie,\n          storagePrefix,\n        );\n      }\n    };\n\n    const sdk = createSdk(\n      addHooks(config, {\n        beforeRequest: beforeRequest(storagePrefix),\n        afterRequest,\n      }),\n    );\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll'],\n      wrapper(storagePrefix),\n    );\n\n    const refreshToken = () => getRefreshToken(storagePrefix);\n    const sessionToken = () => getSessionToken(storagePrefix);\n\n    return Object.assign(wrappedSdk, {\n      getRefreshToken: refreshToken,\n      getSessionToken: sessionToken,\n    }) as any;\n  };\n\nconst wrapper =\n  (prefix?: string): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    clearTokens(prefix);\n\n    return resp;\n  };\n\nexport default withPersistTokens;\n","import { JWTResponse, SdkResponse, ResponseData } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../constants';\nimport { CoreSdk, PasskeyOptions } from '../types';\n\ntype CreateWebauthn = typeof createWebAuthn;\n\nconst withCoreFns =\n  <I extends Parameters<CreateWebauthn>, O extends ReturnType<CreateWebauthn>>(\n    creator: (...args: I) => O,\n  ) =>\n  (...args: I) => {\n    const obj = creator(...args);\n\n    Object.assign(obj.signUp, args[0].webauthn.signUp);\n    Object.assign(obj.signIn, args[0].webauthn.signIn);\n    Object.assign(obj.signUpOrIn, args[0].webauthn.signUpOrIn);\n    Object.assign(obj.update, args[0].webauthn.update);\n\n    return obj as {\n      [K in keyof O]: K extends keyof I[0]['webauthn']\n        ? O[K] & I[0]['webauthn'][K]\n        : O[K];\n    };\n  };\n\n/** Constructs a higher level WebAuthn API that wraps the functions from code-js-sdk */\nconst createWebAuthn = (sdk: CoreSdk) => ({\n  async signUp(\n    identifier: string,\n    name: string,\n    passkeyOptions?: PasskeyOptions,\n  ) {\n    const startResponse = await sdk.webauthn.signUp.start(\n      identifier,\n      window.location.origin,\n      name,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signUp.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  async signIn(identifier: string, passkeyOptions?: PasskeyOptions) {\n    const startResponse = await sdk.webauthn.signIn.start(\n      identifier,\n      window.location.origin,\n      undefined,\n      undefined,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const getResponse = await get(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signIn.finish(\n      startResponse.data.transactionId,\n      getResponse,\n    );\n    return finishResponse;\n  },\n\n  async signUpOrIn(identifier: string, passkeyOptions?: PasskeyOptions) {\n    const startResponse = await sdk.webauthn.signUpOrIn.start(\n      identifier,\n      window.location.origin,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    if (startResponse.data?.create) {\n      const createResponse = await create(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signUp.finish(\n        startResponse.data.transactionId,\n        createResponse,\n      );\n      return finishResponse;\n    } else {\n      const getResponse = await get(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signIn.finish(\n        startResponse.data.transactionId,\n        getResponse,\n      );\n      return finishResponse;\n    }\n  },\n\n  async update(\n    identifier: string,\n    token: string,\n    passkeyOptions?: PasskeyOptions,\n  ) {\n    const startResponse = await sdk.webauthn.update.start(\n      identifier,\n      window.location.origin,\n      token,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as SdkResponse<ResponseData>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.update.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  /** Helper functions for working with WebAuthn browser APIs using JSON data */\n  helpers: {\n    /** Wraps the navigation.credentials.create call to translate JSON inputs and outputs */\n    create,\n    /** Wraps the navigation.credentials.get call to translate JSON inputs and outputs */\n    get,\n    /** Checks if the browser supports WebAuthn, and can optionally require in\n     * addition that the browser supports WebAuthn with built-in biometrics */\n    isSupported,\n    conditional,\n  },\n});\n\n// Helpers functions\n\nasync function create(options: string): Promise<string> {\n  const createOptions = decodeCreateOptions(options);\n  const createResponse = (await navigator.credentials.create(\n    createOptions,\n  )) as AttestationPublicKeyCredential;\n  return encodeCreateResponse(createResponse);\n}\n\nasync function get(options: string): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n/**\n * This function should be used in passkeys autofill (conditional UI)\n * It handles the call to \"navigator.credentials.get\" and adds the required options\n * @param options webauthn start options\n * @param abort: AbortController instance\n * @returns encoded \"navigator.credentials.get\" response\n */\nasync function conditional(\n  options: string,\n  abort: AbortController,\n): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  getOptions.signal = abort.signal;\n  getOptions.mediation = 'conditional' as any;\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n// eslint-disable-next-line import/exports-last\nexport async function isSupported(\n  requirePlatformAuthenticator: boolean = false,\n): Promise<boolean> {\n  if (!IS_BROWSER) {\n    return Promise.resolve(false);\n  }\n  const supported = !!(\n    window.PublicKeyCredential &&\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get\n  );\n  if (\n    supported &&\n    requirePlatformAuthenticator &&\n    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable\n  ) {\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  }\n  return supported;\n}\n\n// Conversion of data structures for Create/Attestation/Register ceremony\n\ntype AttestationPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAttestationResponse;\n};\n\nfunction decodeCreateOptions(value: string): CredentialCreationOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.user.id = decodeBase64Url(options.publicKey.user.id);\n  options.publicKey.excludeCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeCreateResponse(\n  credential: AttestationPublicKeyCredential,\n): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      attestationObject: encodeBase64Url(credential.response.attestationObject),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n    },\n  });\n}\n\n// Conversion of data structures for Get/Assertion/Login ceremony\n\ntype AssertionPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAssertionResponse;\n};\n\nfunction decodeGetOptions(value: string): CredentialRequestOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.allowCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeGetResponse(credential: AssertionPublicKeyCredential): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      authenticatorData: encodeBase64Url(credential.response.authenticatorData),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n      signature: encodeBase64Url(credential.response.signature),\n      userHandle: credential.response.userHandle\n        ? encodeBase64Url(credential.response.userHandle)\n        : undefined,\n    },\n  });\n}\n\n// Conversion between ArrayBuffers and Base64Url strings\n\nfunction decodeBase64Url(value: string): ArrayBufferLike {\n  const base64 = value.replace(/_/g, '/').replace(/-/g, '+');\n  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;\n}\n\nfunction encodeBase64Url(value: ArrayBufferLike): string {\n  const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(value)));\n  return base64.replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '');\n}\n\n// Exports\nexport default withCoreFns(createWebAuthn);\n","export const apiPaths = {\n  fedcm: {\n    config: '/fedcm/config',\n  },\n};\n","import { JWTResponse, SdkResponse, LoginOptions } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport { IS_BROWSER } from '../constants';\nimport { apiPaths } from '../apiPaths';\n\n/**\n * Configuration for OneTap.\n */\ninterface OneTapConfig {\n  /** Whether to auto select. Optional. */\n  auto_select?: boolean;\n\n  /** Whether to cancel on tap outside. Optional. */\n  cancel_on_tap_outside?: boolean;\n\n  /** ID of the prompt parent. Optional. */\n  prompt_parent_id?: string;\n\n  /** Context. Optional. */\n  context?: 'signin' | 'signup' | 'use';\n\n  /** Callback function to handle the intermediate iframe close event. Optional. */\n  intermediate_iframe_close_callback?: () => void;\n\n  /** Whether to support ITP. Optional. */\n  itp_support?: boolean;\n\n  /** Login hint. Optional. */\n  login_hint?: string;\n\n  /** HD. Optional. */\n  hd?: string;\n\n  /** Whether to use FedCM for prompt. Optional. */\n  use_fedcm_for_prompt?: boolean;\n}\n\n/**\n * Response from the credential.\n */\ninterface CredentialResponse {\n  /** Credential. */\n  credential: string;\n\n  /** How the selection was made. */\n  select_by:\n    | 'auto'\n    | 'user'\n    | 'user_1tap'\n    | 'user_2tap'\n    | 'btn'\n    | 'btn_confirm'\n    | 'btn_add_session'\n    | 'btn_confirm_add_session';\n}\n\ninterface FedCMAssertionResponse {\n  token: string;\n  error: {\n    code: string;\n    url: string;\n  };\n}\n\ninterface IdentityProviderConfig {\n  configURL: string;\n  clientId: string;\n}\n\ntype IdentityCredentialRequestOptionsContext =\n  | 'signin'\n  | 'signup'\n  | 'use'\n  | 'continue';\n\ninterface IdentityProviderRequestOptions extends IdentityProviderConfig {\n  nonce?: string;\n  loginHint?: string;\n  domainHint?: string;\n}\n\ninterface IdentityCredentialRequestOptions {\n  providers: IdentityProviderRequestOptions[];\n  context?: IdentityCredentialRequestOptionsContext;\n}\n\ninterface FedCMCredentialRequestOptions {\n  identity?: IdentityCredentialRequestOptions;\n}\n\ntype OneTapInitialize = ({\n  client_id,\n  callback,\n  nonce,\n}: {\n  client_id: string;\n  callback: (res: CredentialResponse) => void;\n  nonce: string;\n} & OneTapConfig) => void;\n\ntype PromptNotification = {\n  isSkippedMoment: () => boolean;\n  isDismissedMoment: () => boolean;\n  getDismissedReason: () => string;\n  getSkippedReason: () => string;\n};\n\n/**\n * Constructs a higher level FedCM API that wraps the functions from code-js-sdk.\n * @param sdk The CoreSdk instance.\n * @returns The FedCM API.\n */\nconst createFedCM = (sdk: CoreSdk, projectId: string) => ({\n  async oneTap(\n    provider?: string,\n    oneTapConfig?: OneTapConfig,\n    loginOptions?: LoginOptions,\n    onSkip?: (reason?: string) => void,\n    onDismissed?: (reason?: string) => void,\n  ) {\n    const readyProvider = provider ?? 'google';\n    const startResponse = await sdk.oauth.startNative(\n      readyProvider,\n      loginOptions,\n      true,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n\n    const { clientId, stateId, nonce } = startResponse.data;\n    const googleClient = await getGoogleClient();\n    return new Promise((resolve) => {\n      const callback = (res: CredentialResponse) => {\n        resolve(\n          sdk.oauth.finishNative(\n            readyProvider,\n            stateId,\n            '',\n            '',\n            res.credential,\n          ),\n        );\n      };\n\n      // initialize google client\n      googleClient.initialize({\n        ...oneTapConfig,\n        itp_support: oneTapConfig?.itp_support ?? true,\n        use_fedcm_for_prompt: oneTapConfig?.use_fedcm_for_prompt ?? true,\n        client_id: clientId,\n        callback,\n        nonce,\n      });\n\n      googleClient.prompt((notification) => {\n        if (onDismissed && notification?.isDismissedMoment()) {\n          const reason = notification.getDismissedReason?.();\n          onDismissed?.(reason);\n          return;\n        }\n\n        // Fallback to onSkip\n        if (onSkip && notification?.isSkippedMoment()) {\n          const reason = notification.getSkippedReason?.();\n          onSkip?.(reason);\n          return;\n        }\n      });\n    });\n  },\n  async launch(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<SdkResponse<JWTResponse>> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    const req: FedCMCredentialRequestOptions = {\n      identity: {\n        context: context || 'signin',\n        providers: [\n          {\n            configURL,\n            clientId: projectId,\n          },\n        ],\n      },\n    };\n    const res = await navigator.credentials?.get(req as any);\n    return sdk.refresh((res as any as FedCMAssertionResponse).token);\n  },\n  isSupported(): boolean {\n    return IS_BROWSER && 'IdentityCredential' in window;\n  },\n  async isLoggedIn(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<boolean> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    try {\n      const req: FedCMCredentialRequestOptions = {\n        identity: {\n          context: context || 'signin',\n          providers: [\n            {\n              configURL,\n              clientId: projectId,\n            },\n          ],\n        },\n      };\n      const res = await navigator.credentials?.get(req as any);\n      return !!res && !!(res as any as FedCMAssertionResponse).token;\n    } catch (e) {\n      // Any error likely indicates no active session.\n      return false;\n    }\n  },\n});\n\n// Helpers functions\nasync function getGoogleClient(): Promise<{\n  initialize: OneTapInitialize;\n  prompt: (cb: (notification: PromptNotification) => void) => void;\n}> {\n  return new Promise((resolve, reject) => {\n    if ((window as any).google) {\n      resolve((window as any).google.accounts.id);\n      return;\n    }\n\n    /* istanbul ignore next */\n    let googleScript = document.getElementById(\n      'google-gsi-client-script',\n    ) as HTMLScriptElement;\n\n    /* istanbul ignore next */\n    if (!googleScript) {\n      googleScript = document.createElement('script');\n      document.head.appendChild(googleScript);\n      googleScript.async = true;\n      googleScript.defer = true;\n      googleScript.id = 'google-gsi-client-script';\n      googleScript.src = 'https://accounts.google.com/gsi/client';\n    }\n\n    /* istanbul ignore next */\n    googleScript.onload = function () {\n      if ((window as any).google) {\n        resolve((window as any).google.accounts.id);\n      } else {\n        reject('Failed to load Google GSI client script - not loaded properly');\n      }\n    };\n    /* istanbul ignore next */\n    googleScript.onerror = function () {\n      reject('Failed to load Google GSI client script - failed to load');\n    };\n  });\n}\n\nexport default createFedCM;\nexport type { OneTapConfig };\n","import { CoreSdk, ReplaceParam } from '../types';\nimport { isSupported } from './webauthn';\n\ntype CoreSdkFlowStartArgs = Parameters<CoreSdk['flow']['start']>;\ntype Options = Pick<\n  CoreSdkFlowStartArgs[1],\n  | 'tenant'\n  | 'redirectUrl'\n  | 'redirectAuth'\n  | 'oidcIdpStateId'\n  | 'samlIdpStateId'\n  | 'samlIdpUsername'\n  | 'ssoAppId'\n  | 'thirdPartyAppId'\n  | 'oidcLoginHint'\n  | 'preview'\n  | 'abTestingKey'\n  | 'client'\n  | 'locale'\n  | 'oidcPrompt'\n  | 'oidcErrorRedirectUri'\n  | 'nativeOptions'\n  | 'thirdPartyAppStateId'\n  | 'applicationScopes'\n> & {\n  lastAuth?: Omit<CoreSdkFlowStartArgs[1]['lastAuth'], 'loginId' | 'name'>;\n};\n\nconst START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL = 1;\n\nexport default (coreSdk: CoreSdk) => ({\n  ...coreSdk.flow,\n  // wrap start fn and adds more data to the start options\n  start: async (...args: ReplaceParam<CoreSdkFlowStartArgs, '1', Options>) => {\n    const webAuthnSupport = await isSupported();\n    const decoratedOptions = {\n      location: window.location.href,\n      ...args[1],\n      deviceInfo: {\n        webAuthnSupport,\n      },\n      startOptionsVersion: START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL,\n    };\n\n    args[1] = decoratedOptions;\n\n    return coreSdk.flow.start(...args);\n  },\n});\n","import createCoreSdk from '@descope/core-js-sdk';\nimport createWebAuthn from './webauthn';\nimport createFedCM from './fedcm';\nimport withFlow from './flow';\nimport { getSessionToken } from '../enhancers/withPersistTokens/helpers';\n\nconst createSdk = (...args: Parameters<typeof createCoreSdk>) => {\n  const coreSdk = createCoreSdk(...args);\n\n  return {\n    ...coreSdk,\n    refresh: (token?: string) => {\n      // Descope use this query param to monitor if refresh is made\n      // When the user is already logged in in the past or not (We want to optimize that in the future)\n      const currentSessionToken = getSessionToken();\n      return coreSdk.refresh(token, { dcs: currentSessionToken ? 't' : 'f' });\n    },\n    flow: withFlow(coreSdk),\n    webauthn: createWebAuthn(coreSdk),\n    fedcm: createFedCM(coreSdk, args[0].projectId),\n  };\n};\n\nexport default createSdk;\n\nexport type CreateWebSdk = typeof createSdk;\nexport type WebSdk = ReturnType<CreateWebSdk>;\n","import { compose } from './enhancers/helpers';\nimport { withAnalytics } from './enhancers/withAnalytics';\nimport { withAutoRefresh } from './enhancers/withAutoRefresh';\nimport { withFingerprint } from './enhancers/withFingerprint';\nimport { withLastLoggedInUser } from './enhancers/withLastLoggedInUser';\nimport { withNotifications } from './enhancers/withNotifications';\nimport withPersistTokens from './enhancers/withPersistTokens';\nimport createSdk from './sdk';\n\nconst decoratedCreateSdk = compose(\n  withFingerprint,\n  withAutoRefresh,\n  withAnalytics,\n  withNotifications,\n  withLastLoggedInUser, // must be one before last due to TS types\n  withPersistTokens, // must be last due to TS known limitation https://github.com/microsoft/TypeScript/issues/30727\n)(createSdk);\n\nexport type { UserResponse } from './types';\n\n// Note: make sure to update ./test/umd.test.ts when adding new constants\nexport {\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './enhancers/withPersistTokens/constants';\n\nexport {\n  ensureFingerprintIds,\n  clearFingerprintData,\n} from './enhancers/withFingerprint/helpers';\n\nexport type { OneTapConfig } from './sdk/fedcm';\n\nexport default decoratedCreateSdk;\n","type Fn = (arg: any) => any;\n\nexport function compose<Input, A1>(\n  fn1: (input: Input) => A1,\n): (input: Input) => A1;\n\nexport function compose<Input, A1, A2>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n): (input: Input) => A2;\n\nexport function compose<Input, A1, A2, A3>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n): (input: Input) => A3;\n\nexport function compose<Input, A1, A2, A3, A4>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n): (input: Input) => A4;\n\nexport function compose<Input, A1, A2, A3, A4, A5>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n): (input: Input) => A5;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n): (input: Input) => A6;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n): (input: Input) => A7;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n): (input: Input) => A8;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n): (input: Input) => A9;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n  fn10: (input: A9) => A10,\n): (input: Input) => A10;\n\n/**\n * Currently there is no way to create a compose function in Typescript without using overloading\n * This function currently support up to 10 wrappers\n * If needed you can add more by duplicating the type and add more parameters\n */\n\nexport function compose(...args: Fn[]) {\n  return (data: any) => args.reduce((acc, elem) => elem(acc), data) as any;\n}\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  createTimerFunctions,\n  getTokenExpiration,\n  millisecondsUntilDate,\n} from './helpers';\nimport { AutoRefreshOptions } from './types';\nimport logger from '../helpers/logger';\nimport { IS_BROWSER, MAX_TIMEOUT } from '../../constants';\nimport { getRefreshToken } from '../withPersistTokens/helpers';\n\n// The amount of time (ms) to trigger the refresh before session expires\nconst REFRESH_THRESHOLD = 20 * 1000; // 20 sec\n\n/**\n * Automatically refresh the session token before it expires\n * It uses the the refresh token that is extracted from API response to do that\n */\nexport const withAutoRefresh =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ autoRefresh, ...config }: Parameters<T>[0] & AutoRefreshOptions) => {\n    if (!autoRefresh) return createSdk(config);\n\n    // if we hold a single timer id, there might be a case where we override it before canceling the timer, this might cause many calls to refresh\n    // in order to prevent it, we hold a list of timers and cancel all of them when a new timer is set, which means we should have one active timer only at a time\n    const { clearAllTimers, setTimer } = createTimerFunctions();\n\n    // we need to hold the expiration time and the refresh token in order to refresh the session\n    // when the user comes back to the tab or from background/lock screen/etc.\n    let sessionExpirationDate: Date;\n    let refreshToken: string;\n    if (IS_BROWSER) {\n      document.addEventListener('visibilitychange', () => {\n        // tab becomes visible and the session is expired, do a refresh\n        if (\n          document.visibilityState === 'visible' &&\n          new Date() > sessionExpirationDate\n        ) {\n          logger.debug('Expiration time passed, refreshing session');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshToken);\n        }\n      });\n    }\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const { refreshJwt, sessionJwt, sessionExpiration } =\n        (await getAuthInfoFromResponse(res)) as any;\n\n      // if we got 401 we want to cancel all timers\n      if (res?.status === 401) {\n        logger.debug('Received 401, canceling all timers');\n        clearAllTimers();\n      } else if (sessionJwt || sessionExpiration) {\n        sessionExpirationDate = getTokenExpiration(\n          sessionJwt,\n          sessionExpiration,\n        );\n        if (!sessionExpirationDate) {\n          logger.debug('Could not extract expiration time from session token');\n          return;\n        }\n        refreshToken = refreshJwt;\n        let timeout =\n          millisecondsUntilDate(sessionExpirationDate) - REFRESH_THRESHOLD;\n\n        if (timeout > MAX_TIMEOUT) {\n          logger.debug(\n            `Timeout is too large (${timeout}ms), setting it to ${MAX_TIMEOUT}ms`,\n          );\n          timeout = MAX_TIMEOUT;\n        }\n        clearAllTimers();\n\n        const refreshTimeStr = new Date(\n          Date.now() + timeout,\n        ).toLocaleTimeString('en-US', { hour12: false });\n        logger.debug(\n          `Setting refresh timer for ${refreshTimeStr}. (${timeout}ms)`,\n        );\n\n        setTimer(() => {\n          logger.debug('Refreshing session due to timer');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshJwt);\n        }, timeout);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n        logger.debug('Clearing all timers');\n        clearAllTimers();\n\n        return resp;\n      };\n\n    return wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n  };\n","import { jwtDecode, JwtPayload } from 'jwt-decode';\nimport logger from '../helpers/logger';\n\n/**\n * Get the JWT expiration WITHOUT VALIDATING the JWT\n * @param token The JWT to extract expiration from\n * @returns The Date for when the JWT expires or null if there is an issue\n */\nexport const getTokenExpiration = (\n  token: string,\n  sessionExpiration: number,\n) => {\n  if (sessionExpiration) {\n    return new Date(sessionExpiration * 1000);\n  }\n\n  logger.debug(\n    'Could not extract expiration time from session token, trying to decode the token',\n  );\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    if (claims.exp) {\n      return new Date(claims.exp * 1000);\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const millisecondsUntilDate = (date: Date) =>\n  date ? date.getTime() - new Date().getTime() : 0;\n\nexport const createTimerFunctions = () => {\n  const timerIds: NodeJS.Timeout[] = [];\n\n  const clearAllTimers = () => {\n    while (timerIds.length) {\n      clearTimeout(timerIds.pop());\n    }\n  };\n\n  const setTimer = (cb: () => void, timeout: number) => {\n    timerIds.push(setTimeout(cb, timeout));\n  };\n\n  return { clearAllTimers, setTimer };\n};\n","import { CreateWebSdk } from '../sdk';\nimport { BeforeRequestHook } from '../types';\nimport { addHooks } from './helpers';\n\n// this is replaced in build time\ndeclare const BUILD_VERSION: string;\n/**\n * Adds analytics headers to requests\n */\nexport const withAnalytics =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) =>\n    createSdk({\n      ...config,\n      baseHeaders: {\n        'x-descope-sdk-name': 'web-js',\n        'x-descope-sdk-version': BUILD_VERSION,\n        ...config.baseHeaders,\n      },\n    });\n"],"names":["addHooks","config","hooks","reduce","acc","key","concat","_a","getAuthInfoFromResponse","async","res","ok","body","clone","json","authInfo","getUserFromResponse","user","hasOwnProperty","undefined","isLocalStorage","localStorage","setLocalStorage","value","setItem","getLocalStorage","getItem","removeLocalStorage","removeItem","logger","args","console","debug","IS_BROWSER","window","MAX_TIMEOUT","Math","pow","SESSION_TOKEN_KEY","REFRESH_TOKEN_KEY","setJwtTokenCookie","name","cookiePath","cookieDomain","cookieExpiration","cookieSameSite","expires","Date","domainMatches","currentDomainParts","location","hostname","split","cookieDomainParts","slice","length","join","isCurrentDomainOrParentDomain","Cookies","set","path","domain","sameSite","secure","getRefreshToken","prefix","getSessionToken","get","clearTokens","remove","FP_EP_URL","VISITOR_SESSION_ID_PARAM","VISITOR_REQUEST_ID_PARAM","FP_STORAGE_KEY","getFPFromStorage","returnExpired","itemStr","item","JSON","parse","getTime","expiry","ensureFingerprintIds","fpKey","baseUrl","sessionId","now","toString","random","substring","endpointUrl","URL","pathname","patterUrl","scriptUrlPattern","agentP","load","apiKey","endpoint","defaultEndpoint","defaultScriptUrlPattern","agent","requestId","linkedId","fpData","createFingerprintObject","stringify","setFPToStorage","ex","warn","clearFingerprintData","beforeRequest","data","LOCAL_STORAGE_LAST_USER_LOGIN_ID","LOCAL_STORAGE_LAST_USER_DISPLAY_NAME","getLastUserLoginId","getLastUserDisplayName","startWrapper","fn","options","loginId","displayName","lastAuth","logoutWrapper","keepOnLogout","resp","createPubSub","cbs","pub","forEach","cb","sub","idx","push","splice","wrapper","create","createOptions","publicKey","challenge","decodeBase64Url","id","excludeCredentials","decodeCreateOptions","createResponse","navigator","credentials","credential","rawId","encodeBase64Url","type","response","attestationObject","clientDataJSON","getOptions","decodeGetOptions","encodeGetResponse","conditional","abort","signal","mediation","isSupported","requirePlatformAuthenticator","Promise","resolve","supported","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","allowCredentials","authenticatorData","signature","userHandle","base64","replace","Uint8Array","from","atob","c","charCodeAt","buffer","btoa","String","fromCharCode","apply","creator","createWebAuthn$1","sdk","signUp","identifier","passkeyOptions","startResponse","webauthn","start","origin","finish","transactionId","signIn","getResponse","signUpOrIn","update","token","helpers","obj","Object","assign","apiPaths","createFedCM","projectId","oneTap","provider","oneTapConfig","loginOptions","onSkip","onDismissed","readyProvider","oauth","startNative","clientId","stateId","nonce","googleClient","reject","google","accounts","googleScript","document","getElementById","createElement","head","appendChild","defer","src","onload","onerror","getGoogleClient","initialize","itp_support","use_fedcm_for_prompt","_b","client_id","callback","finishNative","prompt","notification","isDismissedMoment","reason","getDismissedReason","isSkippedMoment","getSkippedReason","launch","context","req","identity","providers","configURL","httpClient","buildUrl","refresh","isLoggedIn","e","withFlow","coreSdk","flow","webAuthnSupport","decoratedOptions","href","deviceInfo","startOptionsVersion","decoratedCreateSdk","elem","compose","createSdk","fpLoad","__rest","catch","autoRefresh","clearAllTimers","setTimer","timerIds","clearTimeout","pop","timeout","setTimeout","createTimerFunctions","sessionExpirationDate","refreshToken","addEventListener","visibilityState","afterRequest","_req","refreshJwt","sessionJwt","sessionExpiration","status","claims","jwtDecode","exp","getTokenExpiration","date","refreshTimeStr","toLocaleTimeString","hour12","wrapWith","baseHeaders","sessionExpirationPS","sessionPS","userPS","userDetails","wrappedSdk","onSessionTokenChange","onUserChange","onIsAuthenticatedChange","storeLastAuthenticatedUser","keepLastAuthenticatedUserAfterLogout","loginIds","setLastUserLoginId","setLastUserDisplayName","persistTokens","isPersistTokens","sessionTokenViaCookie","storagePrefix","isManagementApi","test","cookieParams","createCoreSdk","currentSessionToken","dcs","createWebAuthn","fedcm"],"mappings":"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"}